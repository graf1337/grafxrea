1. Задание 7. Жадный алгоритм: интервальное планирование
Условие. Даны интервалы [si,fi]. Выбрать максимальное число непересекающихся
интервалов.
Алгоритм: жадный по времени окончания.
Язык примера: Python
def interval_scheduling(intervals):
 intervals.sort(key=lambda x: x[1])
 result = []
 last_end = -1
 for start, end in intervals:
 # ДОПИСАТЬ: если интервал не пересекается с последним выбранным
 return result
Что дописать: условие добавления интервала.

2. Алгоритм кода:
1) Сортируем все интервалы по времени окончания
intervals.sort(key=lambda x: x[1])

2) Инициализируем пустой список для результата и переменную для отслеживания последнего окончания
result = []
last_end = -1

3) Проходим по всем отсортированным интервалам
for start, end in intervals:

4) Проверяем, что текущий интервал не пересекается с последним выбранным
if start >= last_end:

5) Добавляем непересекающийся интервал в результат и обновляем время окончания
result.append((start, end))
last_end = end

3. Временная сложность: O(n log n)

4. Обоснование временной сложности:
Алгоритм состоит из двух основных этапов:
Сортировка интервалов по времени окончания:
intervals.sort(key=lambda x: x[1])
Сложность: O(n log n)
Это стандартная сложность для алгоритма Timsort, используемого в Python
Линейный проход по отсортированным интервалам:
Цикл for start, end in intervals:
Сложность: O(n)
Внутри цикла выполняются только операции сравнения и добавления в список (O(1))
Общая сложность определяется как O(n log n) + O(n) = O(n log n), поскольку при больших n операция сортировки O(n log n) доминирует над линейным проходом O(n).

5. Жадный алгоритм для задачи о 0-1 рюкзаке не гарантирует оптимальное решение, поскольку он принимает локально оптимальные решения без учета глобальной оптимальности. Алгоритм, выбирающий предметы по убыванию отношения ценности к весу, не учитывает, что комбинация нескольких менее "эффективных" предметов может дать большую суммарную ценность при полном использовании вместимости рюкзака.
Контрпример: рюкзак вместимостью 10 кг, предметы: A(6кг, 60), B(5кг, 50), C(5кг, 50). Жадный алгоритм выберет предмет A (ценность 60), но оптимальное решение - предметы B и C (ценность 100). Это происходит потому, что жадный выбор предмета A занимает большую часть вместимости, но оставляет недостаточно места для других ценных предметов, в то время как комбинация меньших предметов полностью использует вместимость рюкзака с большей суммарной ценностью.
