1. Задание 7. Жадный алгоритм: интервальное планирование
Условие. Даны интервалы [si,fi]. Выбрать максимальное число непересекающихся
интервалов.
Алгоритм: жадный по времени окончания.
Язык примера: Python
def interval_scheduling(intervals):
 intervals.sort(key=lambda x: x[1])
 result = []
 last_end = -1
 for start, end in intervals:
 # ДОПИСАТЬ: если интервал не пересекается с последним выбранным
 return result
Что дописать: условие добавления интервала.

2. Алгоритм кода:
1) Сортируем все интервалы по времени окончания
intervals.sort(key=lambda x: x[1])

2) Инициализируем пустой список для результата и переменную для отслеживания последнего окончания
result = []
last_end = -1

3) Проходим по всем отсортированным интервалам
for start, end in intervals:

4) Проверяем, что текущий интервал не пересекается с последним выбранным
if start >= last_end:

5) Добавляем непересекающийся интервал в результат и обновляем время окончания
result.append((start, end))
last_end = end

3. Временная сложность: O(n log n)

4. Обоснование временной сложности:
Алгоритм состоит из двух основных этапов:
Сортировка интервалов по времени окончания:
intervals.sort(key=lambda x: x[1])
Сложность: O(n log n)
Это стандартная сложность для алгоритма Timsort, используемого в Python
Линейный проход по отсортированным интервалам:
Цикл for start, end in intervals:
Сложность: O(n)
Внутри цикла выполняются только операции сравнения и добавления в список (O(1))
Общая сложность определяется как O(n log n) + O(n) = O(n log n), поскольку при больших n операция сортировки O(n log n) доминирует над линейным проходом O(n).

5. Коэффициент аппроксимации для составления расписания (Вариант 7)
Докажите, что коэффициент аппроксимации для жадного алгоритма составления расписани яравен 2(1-1/m).
Доказательство что коэффициент аппроксимации для жадного алгоритма составления расписания равен 2(1-1/m) проводится следующим образом. Рассмотрим задачу составления расписания на m идентичных машинах с целью минимизации времени завершения (makespan). Жадный алгоритм (List Scheduling) назначает каждую работу на машину с наименьшей текущей нагрузкой.
Пусть OPT - оптимальное время завершения, ALG - время завершения жадного алгоритма, J - последняя завершенная работа, t(J) - время выполнения работы J. Имеем две нижние оценки для OPT: OPT ≥ (Σt(i))/m (равномерное распределение нагрузки) и OPT ≥ t(J) (самая длинная работа).
Перед назначением работы J нагрузка L на все машины удовлетворяет неравенству L ≤ (m-1)/m × Σt(i), иначе работа J была бы назначена на другую машину. Тогда время завершения ALG = нагрузка на машину J + t(J) ≤ L/m + t(J). Подставляя оценки, получаем ALG ≤ [(m-1)/m × Σt(i)]/m + OPT ≤ (m-1)/m² × (m × OPT) + OPT = (m-1)/m × OPT + OPT = (2 - 1/m) × OPT.
Таким образом, ALG/OPT ≤ 2 - 1/m = 2(1 - 1/(2m)), что и требовалось доказать.
